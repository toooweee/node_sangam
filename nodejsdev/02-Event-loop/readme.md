# Event Loop

Ваш код JavaScript работает в однопоточном режиме. То есть одновременно выполняется только одно действие

Это ограничение на самом деле очень полезно, так как оно упрощает многие способы программирования, не беспокоясь о проблемах параллелизма.

Вам просто нужно обратить внимание на то, как вы пишете свой код, и избегать всего, что может заблокировать поток, например, синхронных сетевых вызовов или бесконечных циклов.

Любой код JavaScript, который слишком долго возвращает управление циклу событий, блокирует выполнение любого кода JavaScript на странице — даже блокирует поток пользовательского интерфейса — и пользователь не может щелкать мышью, прокручивать страницу и так далее.

Почти все примитивы ввода-вывода в JavaScript являются неблокирующими. Сетевые запросы, операции с файловой системой Node.js и так далее. Блокировка является исключением, и именно поэтому JavaScript так сильно основан на обратных вызовах, а в последнее время на промисах и async/await.

### Стэк вызовов

`Стек вызовов` представляет собой очередь `LIFO` (last in first out). Цикл событий постоянно проверяет стек вызовов на предмет наличия функции, которая должна быть запущена. При этом он добавляет все найденные вызовы функций в стек вызовов и выполняет каждый из них по порядку. 

#### Простое объяснение EventLoop

```javascript
const bar = () => console.log('bar');
const baz = () => console.log('baz');
const foo = () => {
  console.log("foo");
  bar()
  baz()
}

foo()
```
Вывод:
```shell
foo
bar
baz
```

### ES6 Очередь заданий¶
В ECMAScript 2015 появилась концепция `очереди заданий`, которая используется Promises (также представленными в ES6/ES2015). Это способ выполнить результат асинхронной функции как можно быстрее, а не помещать его в конец стека вызовов.

`Промисы`, которые разрешаются до завершения текущей функции, будут выполнены сразу после текущей функции.

Мне кажется удачной аналогия с американскими горками в парке развлечений: очередь сообщений возвращает вас в очередь после всех остальных людей в очереди, в то время как очередь заданий - это билет fastpass, который позволяет вам прокатиться на другом аттракционе сразу после того, как вы закончили предыдущий.

```javascript

const bar = () => console.log('bar');

const baz = () => console.log('baz');

const foo = () => {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =>
        resolve('should be right after baz, before bar')
    ).then((resolve) => console.log(resolve));
    baz();
};

foo();
```

Это большая разница между Promises (и async/await, который построен на promises) и обычными асинхронными функциями через setTimeout() или другие API платформы

